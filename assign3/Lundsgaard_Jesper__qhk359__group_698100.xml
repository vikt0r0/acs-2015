<review for-group="Lundsgaard_Jesper__qhk359__group_698100">
  <exercises>

    <question1>
      <title>Serializability and Locking</title>
      <schedule1>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
      </schedule1>

      <schedule2>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>NO</answer>
        <comment>
          Is correct in regard to conflict-serializable, but does not
          show read/write lock operations
        </comment>
      </schedule2>
    </question1>

    <question2>
      <title>Optimistic Concurrency Control</title>
      <scenario1>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
      </scenario1>

      <scenario2>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>NO</answer>
        <comment>There is a conflict between T1 and T3, as it is not certain if
        T3 read the new or old value of {3}. You did not state weather t3 is
        allowed to commit or not.</comment>
      </scenario2>

      <scenario3>
        <text>
          Is the solution provided both correct and includes a convincing short
          argument justifying it?
        </text>
        <answer>YES</answer>
      </scenario3>

    </question2>
  </exercises>

  <programming>

    <question1>
      <title>Description of implementation and tests</title>
      <q1a>
        <text>
          Does the solution contain a clear description of the approach
          used to achieve before-or-after atomicity?
        </text>
        <answer>YES</answer>
      </q1a>
      <q1b>
        <text>
          Provide comments on any aspects that you found unclear in the
          description of the approach to achieve before-or-after atomicity
        </text>
        <answer>Does not mention the term "two phase locking". Unclear which
        methods uses read and write. Does not mention predicate locking. We
        don't see the logical connection from being "conservative and strict"
        and making sure that "transactions are fully isolated".</answer>
      </q1b>
      <q1c>
        <text>
          Does the code include implementations of Tests 1 and 2 of the
          assignment description as well as of at least another two test
          cases?
        </text>
        <answer>NO</answer>
      </q1c>
      <q1d-i>
        <text>
          Is it tested that the final state resulting from concurrent
          execution
          is correct in that it respects invariants designed in the test?
        </text>
        <answer>YES</answer>
      </q1d-i>
      <q1d-ii>
        <text>
          Is it tested that intermediate reads of the state during concurrent
          execution respect invariants designed in the test, so that it is
          arguable that these intermediate states could be found in an
          equivalent serial schedule?
        </text>
        <answer>YES</answer>
      </q1d-ii>
      <q1e>
        <text>
          Provide comments on why you found that any portions of the test
          descriptions were unclear according to the criteria, and suggestions for
          improvement
        </text>
        <answer>testAddAndRemoveBooks does not use multiple threads, as required
        in the assignment. This test case also seems to be very specific to the
        implementation of the locks. Test 2 should run buyBook/addBook
        continously, and check them some specified number of times --
        implementation does it the other way around.</answer>
      </q1e>
    </question1>

    <question2>
      <title>Correctness argument for locking protocol</title>
      <q2a>
        <text>
          Is the variant of 2PL to which equivalence is being established in
          the correctness argument clearly identified (e.g., conservative, strict,
          conservative strict)?
        </text>
        <answer>YES</answer>
      </q2a>
      <q2b>
        <text>
          Is there a sound argumentation of why the steps in the locking
          protocol designed correspond to steps taken in the chosen variant
          of 2PL?
        </text>
        <answer>YES</answer>
      </q2b>
      <q2c>
        <text>
          Is there an argument for the need to take into account predicate
          reads, with appropriate justification?
        </text>
        <answer>NO</answer>
      </q2c>
      <q2d>
        <text>
          Provide comments on why you found any aspects of the correctness
          argument provided to be lacking, incorrect, or in need of improvement.
        </text>
        <answer>Second time 2PL is mentioned, the strictness is not mentioned
        (but it is first time). No mention of predicate reads.</answer>
      </q2d>
    </question2>

    <question3>
      <title>Deadlocks</title>
      <q3a>
        <text>
          Does the solution contain a correct argument for why deadlocks can
          occur in the locking protocol or why deadlocks cannot occur?
        </text>
        <answer>YES</answer>
      </q3a>
      <q3b>
        <text>
          Provide comments on how the argument provided with respect to
          deadlocks could be improved
        </text>
        <answer>The part from "If we were (...)" makes no sense to me :(</answer>
      </q3b>
    </question3>

    <question4>
      <title>Reflections on scalability</title>
      <q4a>
        <text>
          Is there a sound argument about the scalability limits of the
          concurrent implementation provided?
        </text>
        <answer>NO</answer>
      </q4a>
      <q4b>
        <text>
          Provide comments on how the reflections on scalability could be
          improved
        </text>
        <answer>If you claim concurrency slows down the whole system, then why
        bother with concurrency in the first place? You probably want to give an
        good argument supporting such a statement. Would have been nice to see a
        note if you could gain more concurrency by using a different kind of
        2PL.</answer>
      </q4b>
    </question4>

    <question5>
      <title>Argumentation on decisions made for performance</title>
      <q5a>
        <text>
          Is there a sound argument in the solution about the trade-off between
          locking overhead and concurrency?
        </text>
        <answer>YES</answer>
      </q5a>
      <q5b>
        <text>
          Provide comments on how the argument about performance trade-offs in
          the locking protocol could be improved
        </text>
        <answer>Again, would be nice with considerations for other 2PL
        variants. Also, your addBooks does not lock the whole bookstore. Only
        locks the (newly) created locks for the books it tries to add.</answer>
      </q5b>
    </question5>
  </programming>
</review>
