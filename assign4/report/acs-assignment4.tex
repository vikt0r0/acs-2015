% !TEX TS-program = pdflatex
\documentclass[11pt,a4paper,english]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[obeyspaces, hyphens]{url}
\usepackage[top=4cm, bottom=4cm, left=3cm, right=3cm]{geometry}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{mdwlist}
\usepackage{fancyhdr}
\usepackage{cite}
\usepackage{amsmath}
\usepackage[normalem]{ulem} % ulem enables strikethrough and more, but makes
                            % \emph underline by default :(
\usepackage{babel}
\usepackage{fancyvrb}
\usepackage{verbatimbox}
\usepackage{amsfonts}
\usepackage{amsthm}
%\usepackage{minted}
\usepackage{xcolor}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{csquotes}
\usepackage{array}
\usepackage{lmodern} % better font
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{paralist}
\usepackage[font=footnotesize,labelfont=bf]{caption}
\usepackage{tikz}
\usetikzlibrary{calc, arrows, decorations.markings}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{hyperref} % always load hyper ref in the end
\usepackage{cleveref} % except cleveref
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

\newcommand*\justify{%
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
}

\lstset{
    frame=lrtb,
    captionpos=b,
    belowskip=0pt
}

\captionsetup[listing]{aboveskip=5pt,belowskip=\baselineskip}

\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO: }#1}}

%\definecolor{lightgray}{rgb}{0.95,0.95,0.95}
%\renewcommand\listingscaption{Code}

\newcommand{\concat}{\ensuremath{+\!\!\!\!+\!\!}}

\pagestyle{fancy}
\headheight 35pt

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}

\hyphenation{character-ised}

\rhead{Assignment 4}
\lhead{ACS}

\input{plots}

\begin{document}

\thispagestyle{empty} %fjerner sidetal
\hspace{6cm} \vspace{6cm}
\begin{center}
\textbf{\Huge {Advanced Computer Systems}}\\ \vspace{0.5cm}
\Large{Assignment 4}
\end{center}
\vspace{3cm}
\begin{center}
\Large{\textbf{Truls Asheim, Rasmus Wriedt Larsen, Viktor Hansen}}
\end{center}
\vspace{6.0cm}
\thispagestyle{empty}

\newpage

\section*{Exercises}

\subsection*{Question 1: Recovery Concepts}
\begin{enumerate}
\item In a system forcing writes to disk when a transaction commits, it is \emph{not}
  necessary to implement a scheme for redo, as all committed data will be on
  disk. This is based on the assumption that the system does not crash in the
  middle of writing committed data to disk, which is a very crude assumption.

  In a system with no-steal, we do \emph{not} need to implement at scheme for
  redo, as no uncommitted data will be written to disk.

\item Nonvolatile storage (such as disk) can survive a system crash, but can
  have media failures. Data stored in stable storage is assumed to never be
  lost, even though this does usually not consider extreme cases such as atomic
  bombs. Therefore the major difference is the resources/money required to
  implement either.

\item The rules of Write-Ahead Logging are 1) must write log for data updates
  before writing the new data to disk, and 2) must write all log entries for a
  transaction just before committing.

  These two rules ensures durability (results are persistent). Rules 1) ensures
  that we can undo changes that have been written to disk from transactions that
  have not committed, and rule 2) ensures that if the system crashes immediately
  after a commit (and before data is written), we still have all the necessary
  information to redo the operation.
\end{enumerate}

\subsection*{Question 2: ARIES}
\begin{enumerate}
\item Answer here
\item Answer here
\item Answer here
\item Answer here
\item Answer here
\item Answer here
\end{enumerate}

\section*{Programming Task}
\subsection*{Overview of Implementation}
\subsection*{Discussion on the Performance Measurements}
\begin{enumerate}
\item We initially generate a set of books possible to add to the bookstore,
  which we then use a subset of as the initial books in the bookstore.

  We use \verb|numBooksToAdd| with a value of 5. As 10\% of the $500+100 = 600$
  runs by a worker are ``addBooks interactions'', we will get $60$ such
  interactions per worker, thus resulting in $60 \times 5 = 300$ books attempted
  to be added per worker. Ignoring the effects of random sampling, we would need
  $300 \times \mathtt{numConcurrentWorkloadThreads}$ books in the universe
  initially not added to the bookstore, to make sure every ``addBooks
  interactions'' would expand the bookstore with 5 new books. Note that an
  attempt to add 0 new books will be counted as a successful interaction, and
  will still require to go (briefly) into the \verb|addBooks| method thereby
  congesting the queue for access to the synchronization.

  In our experiments we run a maximum of \todo{???} threads, and create a
  universe of 1000 books (controlled by \verb|NUM_TOTAL_BOOKS|) and initially
  add 400 books to the bookstore (\verb|NUM_INITIAL_ADD_BOOKS|).

  \todo{change these numbers above (both here and in code) so they make sense}

  Book generation is done pseudo-randomly for each book, with ISBNs being
  $1,2,\cdots$. A book becomes an editor pick with a chance of $10\%$, number of
  copies is uniformly randomly picked from the integer interval $[1,20]$. Title
  and author name is randomly generated from the characters \verb|[a-zA-Z]| with
  a length determined by a Gaussian distribution -- but at least length 2. The
  title length has a mean of 10 and a standard deviation of 3, while the author
  name length has a mean of 15 and a standard deviation of 3. These values where
  picked using a rough estimate after look at a bookshelf. Book price is
  irrelevant to this assignment, but is uniformly random in the interval
  $[150,350)$.

  \todo{hardware employed}

  We use the handout values for warmup runs (100) and actual runs (500).

  \todo{measurement procedures (e.g., number of repetitions, statistics used such as average or deviation),}

\item Answer here

\item Answer here
\end{enumerate}

% \acsplot{local data}{rpc data}{y axis label}{max}

\begin{figure}
  \centering
  \acsplot{\throughputlocal}{\throughputrpc}{Throughput}{800}
  \caption{Development in throughput when running different number of
    client threads, when running the backend in same addressspace (local) or
    over RPC.}
  \label{fig:throughput}
\end{figure}

\begin{figure}
  \centering
  \acsplot{\latencylocal}{\latencyrpc}{Latency}{800}
  \caption{Development in latency when running different number of
    client threads, when running the backend in same addressspace (local) or
    over RPC.}
  \label{fig:latency}
\end{figure}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
